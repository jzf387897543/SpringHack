<!DOCTYPE html>

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=0">

  <meta name="description" content="SpringHack的无名技术小站">


	<meta name="keywords" content="Dosk, SpringHack, Hacker">

<link rel="alternate" href="/atom.xml" title="Dosk技术站" type="application/atom+xml">
<meta name="theme-color" content="#5badf0">
<title>深入探究 JavaScript 的函数调用 - Dosk技术站</title>
<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
<link rel="shortcut icon" href="/favicon.png">
<link rel="stylesheet" href="/css/style.css">
<nav class="main-nav">
	
	    <a href="/">← Home</a>
	
	
	    <a href="/about/">About</a>
	
	    <a href="/archives/">Archives</a>
	
	<a class="cta" href="/atom.xml" data-no-instant>Subscribe</a>
</nav>

<section id="wrapper">
    <article class="post">
    <header>
        
            <h1>深入探究 JavaScript 的函数调用</h1>
        
        <h2 class="headline">Mar 22 2017
        
        </h2>
    </header>
</article>
<section id="post-body"><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>可能很多人在学习 JavaScript 过程中碰到过函数参数传递方式的迷惑，本着深入的精神，我想再源码中寻找些答案<br>不过在做这件事之前，首先明确几个概念。抛弃掉值传递、引用传递等固有叫法，回归英文：<br><code>call by reference</code> &amp;&amp; <code>call by value</code> &amp;&amp; <code>call by sharing</code><br>分别是我们理解的 C++ 中的引用传递，值传递。第三种比较迷惑，官方解释是 <code>receives the copy of the reference to object</code> 。我用通俗的话解释一下：<br>Object 可以理解为 key 的集合，Object 对 key 指向的数据是引用性质的(这里不深究是指针实现还是C++引用实现)，函数接收的是一个变量的 copy，变量包含了 Object 的引用 ，是一个值传递。<br>那么很明显，函数传参的时候我们接收到的对象型参其实是实参的复制，所以直接更改型参的指向是不可行的；由于 Object 本身的 key 都是引用，所以修改 key 的指向是可行的。</p>
</blockquote>
<a id="more"></a>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><blockquote>
<p>简单来几段代码即可证明<br>Code 1: 函数能修改 key 指向的数据</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let func = obj =&gt; &#123; obj.name = &apos;Dosk&apos; &#125;;</span><br><span class="line">let obj = &#123;name : &apos;Alxw&apos;&#125;;</span><br><span class="line">console.log(obj);  //&#123; name: &apos;Alxw&apos; &#125;</span><br><span class="line">func(obj)</span><br><span class="line">console.log(obj);  //&#123; name: &apos;Dosk&apos; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Code 2: 函数不能修改 obj</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let func = obj =&gt; &#123; obj = &#123;&#125; &#125;;</span><br><span class="line">let obj = &#123;name : &apos;Alxw&apos;&#125;;</span><br><span class="line">console.log(obj);  //&#123; name: &apos;Alxw&apos; &#125;</span><br><span class="line">func(obj)</span><br><span class="line">console.log(obj);  //&#123; name: &apos;Alxw&apos; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Code 3: 内部 obj 和外部 === 结果相等</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let def = &#123;name : &apos;Alxw&apos;&#125;;</span><br><span class="line">let func = obj =&gt; &#123; console.log(obj === def) &#125;;</span><br><span class="line">func(def);  //true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以第三段代码可能有疑问了，既然 obj 是 def 的复制，为什么 === 操作还能够为真？不是说 === 操作对于 Object 比较的是在内存中的地址么，如果是复制应该是 false 才对啊？<br>所以我们回到 Google V8 的源码来看这件事。</p>
</blockquote>
<h3 id="深入-Google-V8"><a href="#深入-Google-V8" class="headerlink" title="深入 Google V8"></a>深入 Google V8</h3><blockquote>
<p>我们来看看源码里严格等于操作代码部分：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool Object::StrictEquals(Object* that) &#123;</span><br><span class="line">  if (this-&gt;IsNumber()) &#123;</span><br><span class="line">    if (!that-&gt;IsNumber()) return false;</span><br><span class="line">    return NumberEquals(this, that);</span><br><span class="line">  &#125; else if (this-&gt;IsString()) &#123;</span><br><span class="line">    if (!that-&gt;IsString()) return false;</span><br><span class="line">    return String::cast(this)-&gt;Equals(String::cast(that));</span><br><span class="line">  &#125; else if (this-&gt;IsSimd128Value()) &#123;</span><br><span class="line">    if (!that-&gt;IsSimd128Value()) return false;</span><br><span class="line">    return Simd128Value::cast(this)-&gt;Equals(Simd128Value::cast(that));</span><br><span class="line">  &#125;</span><br><span class="line">  return this == that;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看起来应该是最后一种情况，理论上如果 def 和 obj 是不同的对象，那么应该返回 false 才对，这不是推翻了上文所述么？其实不，忽略了一件事，即 Google V8 内部在实例化一个 Object 的时候，本身就是动态实例化，而我们知道在编译型语言中如果动态实例化只能够在堆内存上，即只能够指针引用。这个结论是的证明涉及到 Local 、Handle 等 class 的实现，我觉得太麻烦，有一个简单的证明方式，即搜索源码得到所有调用 <code>Object::StrictEquals</code> 的地方都是直接传入而没有取地址操作。<br>不过有人会问，既然是值传递的变量包含 Object 的引用，理论上也能够修改 Object 才对，为什么第三段代码不能修改呢？<br>很简单的道理，因为我们在 JavaScript 语言逻辑层次上的所谓的操作，只不过是在调用 Google V8 的实例方的法而已，根本不可能操作到这一地步(当然，潜在的 BUG 不算的 -。-)</p>
</blockquote>
<h3 id="重新定义"><a href="#重新定义" class="headerlink" title="重新定义"></a>重新定义</h3><blockquote>
<p>我觉得到这里可以给 <code>call by sharing</code> 重新解释一下了：<br>的确，传递的时候是值传递，但是内容包含了 Object 的指针，而且不能够修改这个指针，他是多个变量共享的。</p>
</blockquote>
<h3 id="另一种简单的证明"><a href="#另一种简单的证明" class="headerlink" title="另一种简单的证明"></a>另一种简单的证明</h3><blockquote>
<p>来来来，看源码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">V8_DEPRECATE_SOON(&quot;Use maybe version&quot;,</span><br><span class="line">                  Local&lt;Value&gt; Call(Local&lt;Value&gt; recv, int argc,</span><br><span class="line">                                    Local&lt;Value&gt; argv[]));</span><br><span class="line">V8_WARN_UNUSED_RESULT MaybeLocal&lt;Value&gt; Call(Local&lt;Context&gt; context,</span><br><span class="line">                                             Local&lt;Value&gt; recv, int argc,</span><br><span class="line">                                             Local&lt;Value&gt; argv[]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的是即将弃用的接口，碰巧我看到的这个版本代码包含大量的这种即将弃用的代码，看看就好。重点是第二个接口，是函数的唯一的调用的接口。里面的 <code>Local&lt;Value&gt;</code> 最终会调用 C++ 的位复制，所以可以简单的证明就是值传递。</p>
</blockquote>
<h3 id="可能是重点"><a href="#可能是重点" class="headerlink" title="可能是重点"></a>可能是重点</h3><blockquote>
<p>别忘了，我们定义的的变量都是类似 <code>Handle&lt;Object&gt;</code> 这种形式的，所以它们之间对象才是共享的，我们所说的 JavaScript 里面变量并不直接指的是 Object 的实例!!!</p>
</blockquote>
<h3 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h3><blockquote>
<p>总之理解起来可能很费劲甚至有错误，但是在 JavaScript 语言层次上能够确定了特性，这才是重要的。</p>
</blockquote>
</section>
    
        
        <h2 class="footline">
            <a href="/tags/Node-js/#Node.js">Node.js</a>, <a href="/tags/函数/#函数">函数</a>
        </h2>
    

    <footer id="post-meta" class="clearfix">
        <a href="/about/">
        <img class="avatar" src="/images/avatar.png">
        <div>
            <span class="dark">Dosk技术站</span>
            <span>SpringHack的无名技术小站</span>
        </div>
        </a>
        <section id="sharing">
            <a title="Share to Twitter" class="twitter" href="https://twitter.com/intent/tweet?text=https://www.dosk.win/2017/03/22/google-v8-function-call/ - 深入探究 JavaScript 的函数调用 @"><span class="icon-twitter">tweet</span></a>
            <a title="Share to Facebook" class="facebook" href="#" onclick="
                window.open(
                  'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
                  'facebook-share-dialog',
                  'width=626,height=436');
                return false;"><span class="icon-facebook-sign">Share</span>
            </a>
        </section>
    </footer>


  <section id="comment">
    <button class="btn" id="loadcmts" onclick="cmts.load();">Load Comments</button>
    <div id="gitment"></div>
    <script src='/js/gitment.browser.js'></script>
    <link rel="stylesheet" href=''>
    <script>
      var cmts={
        load:function cmts(){
          var gitment = new Gitment({
          
            id: "深入探究 JavaScript 的函数调用",
          
            owner: "springhack",
            repo: "SpringHack",
            oauth: {
              client_id: "6c8cd45b9c7d253393be",
              client_secret: "ef45833d84aefdec5b79937d192eeadba3568a64",
            },
          })
          gitment.render('gitment');
          var loadcmt = document.getElementById("loadcmts");
          var imyourfather = loadcmt.parentNode;
          imyourfather.removeChild(loadcmts)
        }
      }
    </script>
  </section>


    
        <ul id="post-list" class="archive readmore">
        <h3>Read more</h3>
        
            <li>
    <aside class="dates">Nov 11 2018</aside>
    <a href="/2018/11/11/2018-11-12.00.01/">关于 exagear 的破解(其实是原理解析)</a>
    <h2></h2>
</li>
        
            <li>
    <aside class="dates">Nov 02 2018</aside>
    <a href="/2018/11/02/2018-11-03/">我又来立 flag 啦</a>
    <h2></h2>
</li>
        
            <li>
    <aside class="dates">May 15 2018</aside>
    <a href="/2018/05/15/node-ffi/">Node-FFI 不得不说的原理</a>
    <h2></h2>
</li>
        
            <li>
    <aside class="dates">Jan 01 2018</aside>
    <a href="/2018/01/01/2018first/">2018年首发</a>
    <h2></h2>
</li>
        
            <li>
    <aside class="dates">Aug 31 2017</aside>
    <a href="/2017/08/31/screencapture/">macOS下截图程序的开发</a>
    <h2></h2>
</li>
        
            <li>
    <aside class="dates">Aug 29 2017</aside>
    <a href="/2017/08/29/bike/">以后骑车上班</a>
    <h2></h2>
</li>
        
            <li>
    <aside class="dates">Jul 02 2017</aside>
    <a href="/2017/07/02/think/">毕业之后的人生计划</a>
    <h2></h2>
</li>
        
            <li>
    <aside class="dates">Apr 18 2017</aside>
    <a href="/2017/04/18/boot2env-update/">React 脚手架更新</a>
    <h2></h2>
</li>
        
            <li>
    <aside class="dates">Apr 09 2017</aside>
    <a href="/2017/04/09/bug-fixer/">做一个专职修 BUG 的码农</a>
    <h2></h2>
</li>
        
            <li>
    <aside class="dates">Mar 22 2017</aside>
    <a href="/2017/03/22/google-v8-function-call/">深入探究 JavaScript 的函数调用</a>
    <h2></h2>
</li>
        
        </ul>
    

	<footer id="footer">
	<div id="social">
		<p class="small">© Copyright 2018
			<a href="/"> SpringHack </a>/
			<a href="https://hexo.io"> Hexo </a>/
			<a href="https://github.com/caisiduo/hexo-theme-lightime"> Lightime</a>
		</p>
	</div>
</footer>
</section>

	<script src="//cdnjs.loli.net/ajax/libs/instantclick/3.0.1/instantclick.min.js" data-no-instant></script>
	<script data-no-instant>
		
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
			ga('create', 'UA-XXXXXXXX-Y', 'auto');
			ga('send', 'pageview');
  			InstantClick.on('change', function() {
  				ga('send', 'pageview', location.pathname + location.search);
			});
		
		InstantClick.init('mousedown');
	</script>



